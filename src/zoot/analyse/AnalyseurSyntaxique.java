//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Tue Mar 22 17:30:40 CET 2022
//----------------------------------------------------

package zoot.analyse;

import zoot.arbre.ArbreAbstrait;
import zoot.arbre.BlocDInstructions;
import zoot.arbre.expressions.*;
import zoot.arbre.fonctions.Fonction;
import zoot.arbre.fonctions.GestionnaireFonctions;
import zoot.arbre.instructions.Affect;
import zoot.arbre.instructions.Ecrire;
import zoot.arbre.instructions.Instruction;
import zoot.arbre.instructions.Retourne;
import zoot.exceptions.AnalyseSyntaxiqueException;
import zoot.exceptions.DoubleDeclarationException;
import zoot.gestionErreurs.Erreur;
import zoot.gestionErreurs.StockageErreurs;
import zoot.tableDesSymboles.Entree;
import zoot.tableDesSymboles.Symbole;
import zoot.tableDesSymboles.TDS;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * CUP v0.11a beta 20060608 generated parser.
 *
 * @version Tue Mar 22 17:30:40 CET 2022
 */
public class AnalyseurSyntaxique extends java_cup.runtime.lr_parser {

    /**
     * Default constructor.
     */
    public AnalyseurSyntaxique() {
        super();
    }

    /**
     * Constructor which sets the default scanner.
     */
    public AnalyseurSyntaxique(java_cup.runtime.Scanner s) {
        super(s);
    }

    /**
     * Constructor which sets the default scanner.
     */
    public AnalyseurSyntaxique(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {
        super(s, sf);
    }

    /**
     * Production table.
     */
    protected static final short[][] _production_table =
            unpackFromStrings(new String[]{
                    "\000\042\000\002\002\004\000\002\002\007\000\002\002" +
                            "\005\000\002\002\011\000\002\004\004\000\002\004\003" +
                            "\000\002\003\004\000\002\003\003\000\002\005\004\000" +
                            "\002\005\003\000\002\016\004\000\002\016\003\000\002" +
                            "\010\004\000\002\010\003\000\002\012\005\000\002\012" +
                            "\006\000\002\012\005\000\002\013\003\000\002\013\003" +
                            "\000\002\013\003\000\002\013\005\000\002\013\006\000" +
                            "\002\020\005\000\002\020\003\000\002\014\003\000\002" +
                            "\014\003\000\002\006\005\000\002\017\005\000\002\011" +
                            "\005\000\002\015\004\000\002\015\005\000\002\007\011" +
                            "\000\002\007\012\000\002\007\010"});

    /**
     * Access to production table.
     */
    public short[][] production_table() {
        return _production_table;
    }

    /**
     * Parse-action table.
     */
    protected static final short[][] _action_table =
            unpackFromStrings(new String[]{
                    "\000\113\000\006\004\004\006\006\001\002\000\010\011" +
                            "\055\016\053\017\052\001\002\000\004\002\113\001\002" +
                            "\000\006\022\010\023\012\001\002\000\012\004\016\013" +
                            "\020\022\010\023\012\001\002\000\004\017\uffe8\001\002" +
                            "\000\012\004\ufffc\013\ufffc\022\ufffc\023\ufffc\001\002\000" +
                            "\004\017\uffe9\001\002\000\004\017\014\001\002\000\004" +
                            "\007\015\001\002\000\012\004\uffe7\013\uffe7\022\uffe7\023" +
                            "\uffe7\001\002\000\010\011\055\016\053\017\052\001\002" +
                            "\000\012\004\ufffd\013\ufffd\022\ufffd\023\ufffd\001\002\000" +
                            "\006\022\010\023\012\001\002\000\010\004\ufff8\022\ufff8" +
                            "\023\ufff8\001\002\000\010\004\105\022\010\023\012\001" +
                            "\002\000\004\017\024\001\002\000\004\014\026\001\002" +
                            "\000\006\004\037\006\040\001\002\000\010\015\031\022" +
                            "\010\023\012\001\002\000\010\015\ufff6\022\ufff6\023\ufff6" +
                            "\001\002\000\010\015\036\022\010\023\012\001\002\000" +
                            "\006\004\uffe4\006\uffe4\001\002\000\004\017\033\001\002" +
                            "\000\004\007\034\001\002\000\010\015\uffe6\022\uffe6\023" +
                            "\uffe6\001\002\000\010\015\ufff7\022\ufff7\023\ufff7\001\002" +
                            "\000\006\004\uffe3\006\uffe3\001\002\000\010\011\055\016" +
                            "\053\017\052\001\002\000\010\004\041\022\010\023\012" +
                            "\001\002\000\010\011\055\016\053\017\052\001\002\000" +
                            "\010\004\ufff4\022\ufff4\023\ufff4\001\002\000\010\004\047" +
                            "\022\010\023\012\001\002\000\004\017\045\001\002\000" +
                            "\004\007\046\001\002\000\010\004\uffe5\022\uffe5\023\uffe5" +
                            "\001\002\000\010\011\055\016\053\017\052\001\002\000" +
                            "\010\004\ufff5\022\ufff5\023\ufff5\001\002\000\012\005\ufffa" +
                            "\011\ufffa\016\ufffa\017\ufffa\001\002\000\004\012\076\001" +
                            "\002\000\010\017\057\020\056\021\060\001\002\000\012" +
                            "\005\073\011\055\016\053\017\052\001\002\000\010\017" +
                            "\057\020\056\021\060\001\002\000\010\007\ufff0\010\ufff0" +
                            "\015\ufff0\001\002\000\012\007\uffee\010\uffee\014\063\015" +
                            "\uffee\001\002\000\010\007\uffef\010\uffef\015\uffef\001\002" +
                            "\000\004\007\062\001\002\000\012\005\ufff3\011\ufff3\016" +
                            "\ufff3\017\ufff3\001\002\000\012\015\065\017\057\020\056" +
                            "\021\060\001\002\000\006\010\uffea\015\uffea\001\002\000" +
                            "\010\007\uffed\010\uffed\015\uffed\001\002\000\006\010\067" +
                            "\015\070\001\002\000\010\017\057\020\056\021\060\001" +
                            "\002\000\010\007\uffec\010\uffec\015\uffec\001\002\000\006" +
                            "\010\uffeb\015\uffeb\001\002\000\012\005\ufffb\011\ufffb\016" +
                            "\ufffb\017\ufffb\001\002\000\010\004\uffe1\022\uffe1\023\uffe1" +
                            "\001\002\000\004\007\075\001\002\000\012\005\ufff1\011" +
                            "\ufff1\016\ufff1\017\ufff1\001\002\000\010\017\057\020\056" +
                            "\021\060\001\002\000\004\007\100\001\002\000\012\005" +
                            "\ufff2\011\ufff2\016\ufff2\017\ufff2\001\002\000\012\005\102" +
                            "\011\055\016\053\017\052\001\002\000\010\004\uffe2\022" +
                            "\uffe2\023\uffe2\001\002\000\012\005\104\011\055\016\053" +
                            "\017\052\001\002\000\010\004\uffe0\022\uffe0\023\uffe0\001" +
                            "\002\000\010\011\055\016\053\017\052\001\002\000\010" +
                            "\004\ufff9\022\ufff9\023\ufff9\001\002\000\012\005\110\011" +
                            "\055\016\053\017\052\001\002\000\004\002\ufffe\001\002" +
                            "\000\012\005\112\011\055\016\053\017\052\001\002\000" +
                            "\004\002\000\001\002\000\004\002\001\001\002\000\012" +
                            "\005\115\011\055\016\053\017\052\001\002\000\004\002" +
                            "\uffff\001\002"});

    /**
     * Access to parse-action table.
     */
    public short[][] action_table() {
        return _action_table;
    }

    /**
     * <code>reduce_goto</code> table.
     */
    protected static final short[][] _reduce_table =
            unpackFromStrings(new String[]{
                    "\000\113\000\004\002\004\001\001\000\006\003\113\012" +
                            "\050\001\001\000\002\001\001\000\010\004\006\006\010" +
                            "\014\012\001\001\000\006\006\016\014\012\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\006\003" +
                            "\110\012\050\001\001\000\002\001\001\000\010\005\021" +
                            "\007\020\014\022\001\001\000\002\001\001\000\006\007" +
                            "\105\014\022\001\001\000\002\001\001\000\004\015\024" +
                            "\001\001\000\002\001\001\000\010\014\031\016\027\017" +
                            "\026\001\001\000\002\001\001\000\006\014\031\017\034" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\006\003\102\012\050\001\001\000\010\010\042\011" +
                            "\041\014\043\001\001\000\006\003\100\012\050\001\001" +
                            "\000\002\001\001\000\006\011\047\014\043\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
                            "\003\053\012\050\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\004\013\073\001\001\000\004" +
                            "\012\071\001\001\000\004\013\060\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\006\013\063\020\065\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
                            "\013\070\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\004\013\076\001\001\000\002\001\001\000" +
                            "\002\001\001\000\004\012\071\001\001\000\002\001\001" +
                            "\000\004\012\071\001\001\000\002\001\001\000\006\003" +
                            "\106\012\050\001\001\000\002\001\001\000\004\012\071" +
                            "\001\001\000\002\001\001\000\004\012\071\001\001\000" +
                            "\002\001\001\000\002\001\001\000\004\012\071\001\001" +
                            "\000\002\001\001"});

    /**
     * Access to <code>reduce_goto</code> table.
     */
    public short[][] reduce_table() {
        return _reduce_table;
    }

    /**
     * Instance of action encapsulation class.
     */
    protected CUP$AnalyseurSyntaxique$actions action_obj;

    /**
     * Action encapsulation object initializer.
     */
    protected void init_actions() {
        action_obj = new CUP$AnalyseurSyntaxique$actions(this);
    }

    /**
     * Invoke a user supplied parse action.
     */
    public java_cup.runtime.Symbol do_action(
            int act_num,
            java_cup.runtime.lr_parser parser,
            java.util.Stack stack,
            int top)
            throws java.lang.Exception {
        /* call code in generated class */
        return action_obj.CUP$AnalyseurSyntaxique$do_action(act_num, parser, stack, top);
    }

    /**
     * Indicates start state.
     */
    public int start_state() {
        return 0;
    }

    /**
     * Indicates start production.
     */
    public int start_production() {
        return 0;
    }

    /**
     * <code>EOF</code> Symbol index.
     */
    public int EOF_sym() {
        return 0;
    }

    /**
     * <code>error</code> Symbol index.
     */
    public int error_sym() {
        return 1;
    }


    public void report_error(String message, Object info) {

        HashMap<Integer, String> lesTerminaux = new HashMap<>();

        lesTerminaux.put(new Integer(CodesLexicaux.DEBUT), "debut");
        lesTerminaux.put(new Integer(CodesLexicaux.FIN), "fin");
        lesTerminaux.put(new Integer(CodesLexicaux.POINTVIRGULE), ";");

        StringBuffer m = new StringBuffer();

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {
                m.append("\tligne : " + (s.left + 1));
                if (s.right >= 0)
                    m.append(" colonne : " + (s.right + 1));
            }

            if (s.value != null) {
                lesTerminaux.put(CodesLexicaux.CSTENTIERE, "" + s.value);
            }

            if (lesTerminaux.containsKey(new Integer(s.sym))) {
                m.append(" dernier token lu : " + lesTerminaux.get(new Integer(s.sym)));
            } else {
                m.append(" expression non terminée");
            }

        }
        throw new AnalyseSyntaxiqueException("" + m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }

}

/**
 * Cup generated class to encapsulate user supplied action code.
 */
class CUP$AnalyseurSyntaxique$actions {


    private final AnalyseurSyntaxique parser;

    /**
     * Constructor
     */
    CUP$AnalyseurSyntaxique$actions(AnalyseurSyntaxique parser) {
        this.parser = parser;
    }

    /**
     * Method with the actual generated action code.
     */
    public final java_cup.runtime.Symbol CUP$AnalyseurSyntaxique$do_action(
            int CUP$AnalyseurSyntaxique$act_num,
            java_cup.runtime.lr_parser CUP$AnalyseurSyntaxique$parser,
            java.util.Stack CUP$AnalyseurSyntaxique$stack,
            int CUP$AnalyseurSyntaxique$top)
            throws java.lang.Exception {
        /* Symbol object for return from actions */
        java_cup.runtime.Symbol CUP$AnalyseurSyntaxique$result;

        /* select the action based on the action number */
        switch (CUP$AnalyseurSyntaxique$act_num) {
            /*. . . . . . . . . . . . . . . . . . . .*/
            case 33: // FONC ::= TYPE IDF PARAM DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).value;
                int pleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int pright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                String p = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                int noBlocFonc = TDS.getInstance().getNoBlocActuel();
                TDS.getInstance().sortieBloc();
                String[] params = p.split(",");
                ArrayList<String> typeParams = new ArrayList<>();
                ArrayList<String> nomParams = new ArrayList<>();
                for (String s : params) {
                    if (s.equals("entier") || s.equals("booleen"))
                        typeParams.add(s);
                    else
                        nomParams.add(s);
                }
                GestionnaireFonctions.getInstance().ajouter(new Fonction(ileft + 1, i, li, typeParams, nomParams, noBlocFonc));
                try {
                    TDS.getInstance().ajouter(new Entree(i, "fonction", typeParams), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("FONC", 5, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 32: // FONC ::= TYPE IDF PARAM VARIABLES LDECL_LOC DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).value;
                int pleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int pright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                String p = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int ldlleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int ldlright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                ArbreAbstrait ldl = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                int noBlocFonc = TDS.getInstance().getNoBlocActuel();
                TDS.getInstance().sortieBloc();
                String[] params = p.split(",");
                ArrayList<String> typeParams = new ArrayList<>();
                ArrayList<String> nomParams = new ArrayList<>();
                for (String s : params) {
                    if (s.equals("entier") || s.equals("booleen"))
                        typeParams.add(s);
                    else
                        nomParams.add(s);
                }
                GestionnaireFonctions.getInstance().ajouter(new Fonction(ileft + 1, i, li, typeParams, nomParams, noBlocFonc));
                try {
                    TDS.getInstance().ajouter(new Entree(i, "fonction", typeParams), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("FONC", 5, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 31: // FONC ::= TYPE IDF PARAM VARIABLES DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int pleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).left;
                int pright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).right;
                String p = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                int noBlocFonc = TDS.getInstance().getNoBlocActuel();
                TDS.getInstance().sortieBloc();
                String[] params = p.split(",");
                ArrayList<String> typeParams = new ArrayList<>();
                ArrayList<String> nomParams = new ArrayList<>();
                for (String s : params) {
                    if (s.equals("entier") || s.equals("booleen"))
                        typeParams.add(s);
                    else
                        nomParams.add(s);
                }
                GestionnaireFonctions.getInstance().ajouter(new Fonction(ileft + 1, i, li, typeParams, nomParams, noBlocFonc));
                try {
                    TDS.getInstance().ajouter(new Entree(i, "fonction", typeParams), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("FONC", 5, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 30: // PARAM ::= PAROUVRANTE LDECL_PARAM PARFERMANTE
            {
                String RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String ld = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = ld;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PARAM", 11, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 29: // PARAM ::= PAROUVRANTE PARFERMANTE
            {
                String RESULT = null;

                TDS tds = TDS.getInstance();
                if (tds.getNoBlocActuel() == 0) {
                    tds.entreeBloc();
                }
                RESULT = "";

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PARAM", 11, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 28: // DECL_LOC ::= TYPE IDF POINTVIRGULE
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                try {
                    TDS.getInstance().ajouter(new Entree(i, "variable"), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("DECL_LOC", 7, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 27: // DECL_PARAM ::= TYPE IDF POINTVIRGULE
            {
                String RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                TDS tds = TDS.getInstance();
                if (tds.getNoBlocActuel() == 0) {
                    tds.entreeBloc();
                }
                try {
                    tds.ajouter(new Entree(i, "variable"), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }
                RESULT = t + "," + i;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("DECL_PARAM", 13, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 26: // DECL ::= TYPE IDF POINTVIRGULE
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                try {
                    TDS.getInstance().ajouter(new Entree(i, "variable"), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("DECL", 4, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 25: // TYPE ::= BOOLEEN
            {
                String RESULT = null;
                RESULT = "booleen";
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("TYPE", 10, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 24: // TYPE ::= ENTIER
            {
                String RESULT = null;
                RESULT = "entier";
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("TYPE", 10, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 23: // LEXP ::= EXP
            {
                ArrayList<Expression> RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                ArrayList<Expression> a = new ArrayList<>();
                a.add(e);
                RESULT = a;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LEXP", 14, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 22: // LEXP ::= LEXP VIRGULE EXP
            {
                ArrayList<Expression> RESULT = null;
                int leleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int leright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                ArrayList<Expression> le = (ArrayList<Expression>) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                le.add(e);
                RESULT = le;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LEXP", 14, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 21: // EXP ::= IDF PAROUVRANTE LEXP PARFERMANTE
            {
                Expression RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int leleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int leright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArrayList<Expression> le = (ArrayList<Expression>) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new AppelFonction(ileft + 1, i, le);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 20: // EXP ::= IDF PAROUVRANTE PARFERMANTE
            {
                Expression RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                RESULT = new AppelFonction(ileft + 1, i);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 19: // EXP ::= IDF
            {
                Expression RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Idf(i, ileft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 18: // EXP ::= CSTBOOLEENNE
            {
                Expression RESULT = null;
                int cleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int cright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String c = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new ConstanteBooleenne(c, cleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 17: // EXP ::= CSTENTIERE
            {
                Expression RESULT = null;
                int cleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int cright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String c = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new ConstanteEntiere(c, cleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 16: // INST ::= RETOURNE EXP POINTVIRGULE
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Retourne(eleft + 1, e);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 15: // INST ::= IDF EGAL EXP POINTVIRGULE
            {
                Instruction RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Affect(new Idf(i, ileft + 1), e, eleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 14: // INST ::= ECRIRE EXP POINTVIRGULE
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Ecrire(e, eleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 13: // LDECL_LOC ::= DECL_LOC
            {
                ArbreAbstrait RESULT = null;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_LOC", 6, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 12: // LDECL_LOC ::= LDECL_LOC DECL_LOC
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_LOC", 6, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 11: // LDECL_PARAM ::= DECL_PARAM
            {
                String RESULT = null;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String d = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = d;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_PARAM", 12, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 10: // LDECL_PARAM ::= LDECL_PARAM DECL_PARAM
            {
                String RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String ld = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String d = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = ld + "," + d;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_PARAM", 12, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 9: // LFONC ::= FONC
            {
                ArbreAbstrait RESULT = null;
                int fleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int fright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait f = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                BlocDInstructions b = new BlocDInstructions(fleft + 1);
                b.ajouter(f);
                RESULT = b;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LFONC", 3, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 8: // LFONC ::= LFONC FONC
            {
                ArbreAbstrait RESULT = null;
                int lfleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int lfright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait lf = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int fleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int fright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait f = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                ((BlocDInstructions) lf).ajouter(f);
                RESULT = lf;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LFONC", 3, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 7: // LINST ::= INST
            {
                ArbreAbstrait RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Instruction i = (Instruction) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                BlocDInstructions b = new BlocDInstructions(ileft + 1);
                b.ajouter(i);
                RESULT = b;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LINST", 1, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 6: // LINST ::= LINST INST
            {
                ArbreAbstrait RESULT = null;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Instruction i = (Instruction) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                ((BlocDInstructions) li).ajouter(i);
                RESULT = li;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LINST", 1, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 5: // LDECL ::= DECL
            {
                ArbreAbstrait RESULT = null;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL", 2, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 4: // LDECL ::= LDECL DECL
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL", 2, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 3: // PROG ::= VARIABLES LDECL FONCTIONS LFONC DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int lfleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int lfright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                ArbreAbstrait lf = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = li;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PROG", 0, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 2: // PROG ::= DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = li;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PROG", 0, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 1: // PROG ::= VARIABLES LDECL DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = li;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PROG", 0, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 0: // $START ::= PROG EOF
            {
                Object RESULT = null;
                int start_valleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int start_valright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait start_val = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = start_val;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("$START", 0, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            /* ACCEPT */
            CUP$AnalyseurSyntaxique$parser.done_parsing();
            return CUP$AnalyseurSyntaxique$result;

            /* . . . . . .*/
            default:
                throw new Exception(
                        "Invalid action number found in internal parse table");

        }
    }
}

