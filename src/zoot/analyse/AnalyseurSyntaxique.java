//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Fri Mar 25 11:55:04 CET 2022
//----------------------------------------------------

package zoot.analyse;

import zoot.arbre.ArbreAbstrait;
import zoot.arbre.BlocDInstructions;
import zoot.arbre.expressions.*;
import zoot.arbre.expressions.operateurs.binaires.Addition;
import zoot.arbre.expressions.operateurs.binaires.Multiplication;
import zoot.arbre.expressions.operateurs.unaires.Moins;
import zoot.arbre.expressions.operateurs.unaires.Parenthese;
import zoot.arbre.fonctions.Fonction;
import zoot.arbre.fonctions.GestionnaireFonctions;
import zoot.arbre.instructions.Affect;
import zoot.arbre.instructions.Ecrire;
import zoot.arbre.instructions.Instruction;
import zoot.arbre.instructions.Retourne;
import zoot.exceptions.AnalyseSyntaxiqueException;
import zoot.exceptions.DoubleDeclarationException;
import zoot.gestionErreurs.Erreur;
import zoot.gestionErreurs.StockageErreurs;
import zoot.tableDesSymboles.Entree;
import zoot.tableDesSymboles.Symbole;
import zoot.tableDesSymboles.TDS;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * CUP v0.11a beta 20060608 generated parser.
 *
 * @version Fri Mar 25 11:55:04 CET 2022
 */
public class AnalyseurSyntaxique extends java_cup.runtime.lr_parser {

    /**
     * Default constructor.
     */
    public AnalyseurSyntaxique() {
        super();
    }

    /**
     * Constructor which sets the default scanner.
     */
    public AnalyseurSyntaxique(java_cup.runtime.Scanner s) {
        super(s);
    }

    /**
     * Constructor which sets the default scanner.
     */
    public AnalyseurSyntaxique(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {
        super(s, sf);
    }

    /**
     * Production table.
     */
    protected static final short[][] _production_table =
            unpackFromStrings(new String[]{
                    "\000\043\000\002\002\004\000\002\002\011\000\002\004" +
                            "\004\000\002\004\003\000\002\003\004\000\002\003\003" +
                            "\000\002\005\004\000\002\005\003\000\002\016\004\000" +
                            "\002\016\003\000\002\010\004\000\002\010\003\000\002" +
                            "\012\005\000\002\012\006\000\002\012\005\000\002\013" +
                            "\003\000\002\013\003\000\002\013\003\000\002\013\005" +
                            "\000\002\013\006\000\002\013\005\000\002\013\005\000" +
                            "\002\013\004\000\002\013\005\000\002\020\005\000\002" +
                            "\020\003\000\002\014\003\000\002\014\003\000\002\006" +
                            "\005\000\002\017\005\000\002\011\005\000\002\015\004" +
                            "\000\002\015\005\000\002\007\011\000\002\007\012"});

    /**
     * Access to production table.
     */
    public short[][] production_table() {
        return _production_table;
    }

    /**
     * Parse-action table.
     */
    protected static final short[][] _action_table =
            unpackFromStrings(new String[]{
                    "\000\113\000\004\006\005\001\002\000\004\002\115\001" +
                            "\002\000\006\025\010\026\011\001\002\000\010\013\016" +
                            "\025\010\026\011\001\002\000\010\013\ufffe\025\ufffe\026" +
                            "\ufffe\001\002\000\004\022\uffe6\001\002\000\004\022\uffe7" +
                            "\001\002\000\004\022\013\001\002\000\004\007\014\001" +
                            "\002\000\010\013\uffe5\025\uffe5\026\uffe5\001\002\000\010" +
                            "\013\uffff\025\uffff\026\uffff\001\002\000\006\025\010\026" +
                            "\011\001\002\000\010\004\ufffa\025\ufffa\026\ufffa\001\002" +
                            "\000\010\004\111\025\010\026\011\001\002\000\004\022" +
                            "\022\001\002\000\004\014\024\001\002\000\004\006\035" +
                            "\001\002\000\010\015\027\025\010\026\011\001\002\000" +
                            "\010\015\ufff8\025\ufff8\026\ufff8\001\002\000\010\015\034" +
                            "\025\010\026\011\001\002\000\004\006\uffe2\001\002\000" +
                            "\004\022\031\001\002\000\004\007\032\001\002\000\010" +
                            "\015\uffe4\025\uffe4\026\uffe4\001\002\000\010\015\ufff9\025" +
                            "\ufff9\026\ufff9\001\002\000\004\006\uffe1\001\002\000\010" +
                            "\004\036\025\010\026\011\001\002\000\010\011\052\016" +
                            "\047\022\050\001\002\000\010\004\ufff6\025\ufff6\026\ufff6" +
                            "\001\002\000\010\004\044\025\010\026\011\001\002\000" +
                            "\004\022\042\001\002\000\004\007\043\001\002\000\010" +
                            "\004\uffe3\025\uffe3\026\uffe3\001\002\000\010\011\052\016" +
                            "\047\022\050\001\002\000\010\004\ufff7\025\ufff7\026\ufff7" +
                            "\001\002\000\012\005\ufffc\011\ufffc\016\ufffc\022\ufffc\001" +
                            "\002\000\014\014\060\021\056\022\054\023\053\024\055" +
                            "\001\002\000\004\012\102\001\002\000\012\005\101\011" +
                            "\052\016\047\022\050\001\002\000\014\014\060\021\056" +
                            "\022\054\023\053\024\055\001\002\000\014\007\ufff2\010" +
                            "\ufff2\015\ufff2\017\ufff2\020\ufff2\001\002\000\016\007\ufff0" +
                            "\010\ufff0\014\071\015\ufff0\017\ufff0\020\ufff0\001\002\000" +
                            "\014\007\ufff1\010\ufff1\015\ufff1\017\ufff1\020\ufff1\001\002" +
                            "\000\014\014\060\021\056\022\054\023\053\024\055\001" +
                            "\002\000\010\007\067\017\063\020\062\001\002\000\014" +
                            "\014\060\021\056\022\054\023\053\024\055\001\002\000" +
                            "\010\015\064\017\063\020\062\001\002\000\014\014\060" +
                            "\021\056\022\054\023\053\024\055\001\002\000\014\014" +
                            "\060\021\056\022\054\023\053\024\055\001\002\000\014" +
                            "\007\uffea\010\uffea\015\uffea\017\uffea\020\uffea\001\002\000" +
                            "\014\007\uffed\010\uffed\015\uffed\017\uffed\020\062\001\002" +
                            "\000\014\007\uffec\010\uffec\015\uffec\017\uffec\020\uffec\001" +
                            "\002\000\012\005\ufff5\011\ufff5\016\ufff5\022\ufff5\001\002" +
                            "\000\014\007\uffeb\010\uffeb\015\uffeb\017\063\020\062\001" +
                            "\002\000\016\014\060\015\073\021\056\022\054\023\053" +
                            "\024\055\001\002\000\012\010\uffe8\015\uffe8\017\063\020" +
                            "\062\001\002\000\014\007\uffef\010\uffef\015\uffef\017\uffef" +
                            "\020\uffef\001\002\000\006\010\075\015\076\001\002\000" +
                            "\014\014\060\021\056\022\054\023\053\024\055\001\002" +
                            "\000\014\007\uffee\010\uffee\015\uffee\017\uffee\020\uffee\001" +
                            "\002\000\012\010\uffe9\015\uffe9\017\063\020\062\001\002" +
                            "\000\012\005\ufffd\011\ufffd\016\ufffd\022\ufffd\001\002\000" +
                            "\010\004\uffdf\025\uffdf\026\uffdf\001\002\000\014\014\060" +
                            "\021\056\022\054\023\053\024\055\001\002\000\010\007" +
                            "\104\017\063\020\062\001\002\000\012\005\ufff4\011\ufff4" +
                            "\016\ufff4\022\ufff4\001\002\000\010\007\106\017\063\020" +
                            "\062\001\002\000\012\005\ufff3\011\ufff3\016\ufff3\022\ufff3" +
                            "\001\002\000\012\005\110\011\052\016\047\022\050\001" +
                            "\002\000\010\004\uffe0\025\uffe0\026\uffe0\001\002\000\010" +
                            "\011\052\016\047\022\050\001\002\000\010\004\ufffb\025" +
                            "\ufffb\026\ufffb\001\002\000\012\005\114\011\052\016\047" +
                            "\022\050\001\002\000\004\002\000\001\002\000\004\002" +
                            "\001\001\002"});

    /**
     * Access to parse-action table.
     */
    public short[][] action_table() {
        return _action_table;
    }

    /**
     * <code>reduce_goto</code> table.
     */
    protected static final short[][] _reduce_table =
            unpackFromStrings(new String[]{
                    "\000\113\000\004\002\003\001\001\000\002\001\001\000" +
                            "\010\004\005\006\006\014\011\001\001\000\006\006\014" +
                            "\014\011\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\010\005\017\007\016\014" +
                            "\020\001\001\000\002\001\001\000\006\007\111\014\020" +
                            "\001\001\000\002\001\001\000\004\015\022\001\001\000" +
                            "\002\001\001\000\010\014\027\016\025\017\024\001\001" +
                            "\000\002\001\001\000\006\014\027\017\032\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\010\010" +
                            "\037\011\036\014\040\001\001\000\006\003\106\012\045" +
                            "\001\001\000\002\001\001\000\006\011\044\014\040\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\006\003\050\012\045\001\001\000\002\001\001\000" +
                            "\002\001\001\000\004\013\104\001\001\000\002\001\001" +
                            "\000\004\012\077\001\001\000\004\013\056\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
                            "\013\067\001\001\000\002\001\001\000\004\013\060\001" +
                            "\001\000\002\001\001\000\004\013\065\001\001\000\004" +
                            "\013\064\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
                            "\013\071\020\073\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\004\013\076\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\004\013\102\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\004\012" +
                            "\077\001\001\000\002\001\001\000\006\003\112\012\045" +
                            "\001\001\000\002\001\001\000\004\012\077\001\001\000" +
                            "\002\001\001\000\002\001\001"});

    /**
     * Access to <code>reduce_goto</code> table.
     */
    public short[][] reduce_table() {
        return _reduce_table;
    }

    /**
     * Instance of action encapsulation class.
     */
    protected CUP$AnalyseurSyntaxique$actions action_obj;

    /**
     * Action encapsulation object initializer.
     */
    protected void init_actions() {
        action_obj = new CUP$AnalyseurSyntaxique$actions(this);
    }

    /**
     * Invoke a user supplied parse action.
     */
    public java_cup.runtime.Symbol do_action(
            int act_num,
            java_cup.runtime.lr_parser parser,
            java.util.Stack stack,
            int top)
            throws java.lang.Exception {
        /* call code in generated class */
        return action_obj.CUP$AnalyseurSyntaxique$do_action(act_num, parser, stack, top);
    }

    /**
     * Indicates start state.
     */
    public int start_state() {
        return 0;
    }

    /**
     * Indicates start production.
     */
    public int start_production() {
        return 0;
    }

    /**
     * <code>EOF</code> Symbol index.
     */
    public int EOF_sym() {
        return 0;
    }

    /**
     * <code>error</code> Symbol index.
     */
    public int error_sym() {
        return 1;
    }


    public void report_error(String message, Object info) {

        HashMap<Integer, String> lesTerminaux = new HashMap<>();

        lesTerminaux.put(new Integer(CodesLexicaux.DEBUT), "debut");
        lesTerminaux.put(new Integer(CodesLexicaux.FIN), "fin");
        lesTerminaux.put(new Integer(CodesLexicaux.POINTVIRGULE), ";");

        StringBuffer m = new StringBuffer();

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {
                m.append("\tligne : " + (s.left + 1));
                if (s.right >= 0)
                    m.append(" colonne : " + (s.right + 1));
            }

            if (s.value != null) {
                lesTerminaux.put(CodesLexicaux.CSTENTIERE, "" + s.value);
            }

            if (lesTerminaux.containsKey(new Integer(s.sym))) {
                m.append(" dernier token lu : " + lesTerminaux.get(new Integer(s.sym)));
            } else {
                m.append(" expression non terminée");
            }

        }
        throw new AnalyseSyntaxiqueException("" + m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }

}

/**
 * Cup generated class to encapsulate user supplied action code.
 */
class CUP$AnalyseurSyntaxique$actions {


    private final AnalyseurSyntaxique parser;

    /**
     * Constructor
     */
    CUP$AnalyseurSyntaxique$actions(AnalyseurSyntaxique parser) {
        this.parser = parser;
    }

    /**
     * Method with the actual generated action code.
     */
    public final java_cup.runtime.Symbol CUP$AnalyseurSyntaxique$do_action(
            int CUP$AnalyseurSyntaxique$act_num,
            java_cup.runtime.lr_parser CUP$AnalyseurSyntaxique$parser,
            java.util.Stack CUP$AnalyseurSyntaxique$stack,
            int CUP$AnalyseurSyntaxique$top)
            throws java.lang.Exception {
        /* Symbol object for return from actions */
        java_cup.runtime.Symbol CUP$AnalyseurSyntaxique$result;

        /* select the action based on the action number */
        switch (CUP$AnalyseurSyntaxique$act_num) {
            /*. . . . . . . . . . . . . . . . . . . .*/
            case 34: // FONC ::= TYPE IDF PARAM VARIABLES LDECL_LOC DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).value;
                int pleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int pright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                String p = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int ldlleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int ldlright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                ArbreAbstrait ldl = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                int noBlocFonc = TDS.getInstance().getNoBlocActuel();
                TDS.getInstance().sortieBloc();
                String[] params = p.split(",");
                ArrayList<String> typeParams = new ArrayList<>();
                ArrayList<String> nomParams = new ArrayList<>();
                for (String s : params) {
                    if (s.equals("entier") || s.equals("booleen"))
                        typeParams.add(s);
                    else
                        nomParams.add(s);
                }
                GestionnaireFonctions.getInstance().ajouter(new Fonction(ileft + 1, i, li, typeParams, nomParams, noBlocFonc));
                try {
                    TDS.getInstance().ajouter(new Entree(i, "fonction", typeParams), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("FONC", 5, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 33: // FONC ::= TYPE IDF PARAM VARIABLES DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int pleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).left;
                int pright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).right;
                String p = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                int noBlocFonc = TDS.getInstance().getNoBlocActuel();
                TDS.getInstance().sortieBloc();
                String[] params = p.split(",");
                ArrayList<String> typeParams = new ArrayList<>();
                ArrayList<String> nomParams = new ArrayList<>();
                for (String s : params) {
                    if (s.equals("entier") || s.equals("booleen"))
                        typeParams.add(s);
                    else
                        nomParams.add(s);
                }
                GestionnaireFonctions.getInstance().ajouter(new Fonction(ileft + 1, i, li, typeParams, nomParams, noBlocFonc));
                try {
                    TDS.getInstance().ajouter(new Entree(i, "fonction", typeParams), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("FONC", 5, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 32: // PARAM ::= PAROUVRANTE LDECL_PARAM PARFERMANTE
            {
                String RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String ld = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = ld;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PARAM", 11, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 31: // PARAM ::= PAROUVRANTE PARFERMANTE
            {
                String RESULT = null;

                TDS tds = TDS.getInstance();
                if (tds.getNoBlocActuel() == 0) {
                    tds.entreeBloc();
                }
                RESULT = "";

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PARAM", 11, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 30: // DECL_LOC ::= TYPE IDF POINTVIRGULE
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                try {
                    TDS.getInstance().ajouter(new Entree(i, "variable"), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("DECL_LOC", 7, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 29: // DECL_PARAM ::= TYPE IDF POINTVIRGULE
            {
                String RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                TDS tds = TDS.getInstance();
                if (tds.getNoBlocActuel() == 0) {
                    tds.entreeBloc();
                }
                try {
                    tds.ajouter(new Entree(i, "variable"), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }
                RESULT = t + "," + i;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("DECL_PARAM", 13, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 28: // DECL ::= TYPE IDF POINTVIRGULE
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                try {
                    TDS.getInstance().ajouter(new Entree(i, "variable"), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("DECL", 4, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 27: // TYPE ::= BOOLEEN
            {
                String RESULT = null;
                RESULT = "booleen";
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("TYPE", 10, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 26: // TYPE ::= ENTIER
            {
                String RESULT = null;
                RESULT = "entier";
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("TYPE", 10, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 25: // LEXP ::= EXP
            {
                ArrayList<Expression> RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                ArrayList<Expression> a = new ArrayList<>();
                a.add(e);
                RESULT = a;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LEXP", 14, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 24: // LEXP ::= LEXP VIRGULE EXP
            {
                ArrayList<Expression> RESULT = null;
                int leleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int leright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                ArrayList<Expression> le = (ArrayList<Expression>) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                le.add(e);
                RESULT = le;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LEXP", 14, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 23: // EXP ::= PAROUVRANTE EXP PARFERMANTE
            {
                Expression RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Parenthese(eleft + 1, e);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 22: // EXP ::= MOINS EXP
            {
                Expression RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Moins(eleft + 1, e);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 21: // EXP ::= EXP MULT EXP
            {
                Expression RESULT = null;
                int egleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int egright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression eg = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int edleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int edright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression ed = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Multiplication(egleft + 1, eg, ed);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 20: // EXP ::= EXP PLUS EXP
            {
                Expression RESULT = null;
                int egleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int egright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression eg = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int edleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int edright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression ed = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Addition(egleft + 1, eg, ed);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 19: // EXP ::= IDF PAROUVRANTE LEXP PARFERMANTE
            {
                Expression RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int leleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int leright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArrayList<Expression> le = (ArrayList<Expression>) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new AppelFonction(ileft + 1, i, le);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 18: // EXP ::= IDF PAROUVRANTE PARFERMANTE
            {
                Expression RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                RESULT = new AppelFonction(ileft + 1, i);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 17: // EXP ::= IDF
            {
                Expression RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Idf(i, ileft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 16: // EXP ::= CSTBOOLEENNE
            {
                Expression RESULT = null;
                int cleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int cright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String c = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new ConstanteBooleenne(c, cleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 15: // EXP ::= CSTENTIERE
            {
                Expression RESULT = null;
                int cleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int cright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String c = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new ConstanteEntiere(c, cleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 14: // INST ::= RETOURNE EXP POINTVIRGULE
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Retourne(eleft + 1, e);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 13: // INST ::= IDF EGAL EXP POINTVIRGULE
            {
                Instruction RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Affect(new Idf(i, ileft + 1), e, eleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 12: // INST ::= ECRIRE EXP POINTVIRGULE
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Ecrire(e, eleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 11: // LDECL_LOC ::= DECL_LOC
            {
                ArbreAbstrait RESULT = null;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_LOC", 6, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 10: // LDECL_LOC ::= LDECL_LOC DECL_LOC
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_LOC", 6, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 9: // LDECL_PARAM ::= DECL_PARAM
            {
                String RESULT = null;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String d = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = d;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_PARAM", 12, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 8: // LDECL_PARAM ::= LDECL_PARAM DECL_PARAM
            {
                String RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String ld = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String d = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = ld + "," + d;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_PARAM", 12, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 7: // LFONC ::= FONC
            {
                ArbreAbstrait RESULT = null;
                int fleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int fright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait f = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                BlocDInstructions b = new BlocDInstructions(fleft + 1);
                b.ajouter(f);
                RESULT = b;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LFONC", 3, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 6: // LFONC ::= LFONC FONC
            {
                ArbreAbstrait RESULT = null;
                int lfleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int lfright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait lf = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int fleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int fright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait f = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                ((BlocDInstructions) lf).ajouter(f);
                RESULT = lf;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LFONC", 3, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 5: // LINST ::= INST
            {
                ArbreAbstrait RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Instruction i = (Instruction) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                BlocDInstructions b = new BlocDInstructions(ileft + 1);
                b.ajouter(i);
                RESULT = b;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LINST", 1, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 4: // LINST ::= LINST INST
            {
                ArbreAbstrait RESULT = null;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Instruction i = (Instruction) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                ((BlocDInstructions) li).ajouter(i);
                RESULT = li;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LINST", 1, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 3: // LDECL ::= DECL
            {
                ArbreAbstrait RESULT = null;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL", 2, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 2: // LDECL ::= LDECL DECL
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL", 2, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 1: // PROG ::= VARIABLES LDECL FONCTIONS LFONC DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int lfleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int lfright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                ArbreAbstrait lf = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = li;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PROG", 0, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 0: // $START ::= PROG EOF
            {
                Object RESULT = null;
                int start_valleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int start_valright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait start_val = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = start_val;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("$START", 0, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            /* ACCEPT */
            CUP$AnalyseurSyntaxique$parser.done_parsing();
            return CUP$AnalyseurSyntaxique$result;

            /* . . . . . .*/
            default:
                throw new Exception(
                        "Invalid action number found in internal parse table");

        }
    }
}

